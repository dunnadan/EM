abstract sig Signal {}
one sig TurnSignal extends Signal {}
one sig EmergencyBreakLight extends Signal {}
one sig AdaptiveHighBeam extends Signal {}
one sig LowBeamHeadlights extends Signal {}
one sig CorneringLights extends Signal {}

-- done this way instead of lone sing xSignal extends Signal {}
-- to appear the same name in the mode
-- same expressive power, better visual mode, little extra boilerplate
var sig On in Signal {} 
var sig Off in Signal {}
fact oneModeSignal { 
	always (
 		Signal = On + Off and
		no On & Off
	)
}


abstract sig Light {}
one sig Blinker extends Light {}
one sig LowBeamHeadLight extends Light {}
one sig HighBeamHeadLight extends Light {}
one sig CorneringLight extends Light {}
one sig BrakeLight extends Light {}
one sig TailLight extends Light {}
one sig ReverseLight extends Light {}

one sig Car {
	var frontRight: set Light,
	var frontLeft: set Light,
	var middleLeft: set Blinker,
	var middleRight: set Blinker,
	var backRight: set Light,
	var backLeft: set Light,
	var top: lone BrakeLight
}

fact notAllowedInFront {
	let front = Car.frontRight + Car.frontLeft {
		always (
			BrakeLight not in front or
			TailLight not in front or
			ReverseLight not in front
		)
	}
}

fact notAllowedInBack {
	let back = Car.backRight + Car.backLeft {
		always (
			LowBeamHeadLight not in back or
			HighBeamHeadLight not in back or
			CorneringLight not in back
		)
	}
}


fact alwaysBlinkAllLights {
	always (
		Blinker in (Car.frontRight + Car.middleRight + Car.backRight)
				implies Blinker in Car.frontRight and
						Blinker in Car.middleRight and
						Blinker in Car.backRight
	)
	always (
		Blinker in (Car.frontLeft + Car.middleLeft + Car.backLeft)
				implies Blinker in Car.frontLeft and
						Blinker in Car.middleLeft and
						Blinker in Car.backLeft
	)
}

fact onlyOneBlinker {
	always (
		Blinker in Car.middleRight implies Blinker not in Car.middleLeft
	)
	always (
		Blinker in Car.middleLeft implies Blinker not in Car.middleRight
	)
}

-- confirm this
-- do the same for lbh and hbh
fact alwaysBrakeAllBackLights {
	always (
		BrakeLight in (Car.backRight + Car.backLeft)
				implies BrakeLight in Car.backRight and
						BrakeLight in Car.backLeft
	)
}


one sig Input {
	var pitmanArm: one PitmanArm,
	var lightRotarySwitch: one LightRotarySwitch
}

abstract sig PitmanArm {
 -- 5ยบ/7ยบ could be done with a ternary relation here
 -- but some since ยบ doesn't matter for left and right
 -- that would allow to represent "impossible" states
 -- hence this solution
}
one sig PitmanArmNeutral extends PitmanArm {}
one sig PitmanArmUp5 extends PitmanArm {}
one sig PitmanArmUp7 extends PitmanArm {}
one sig PitmanArmDown5 extends PitmanArm {}
one sig PitmanArmDown7 extends PitmanArm {}
one sig PitmanArmLeft extends PitmanArm {}
one sig PitmanArmRight extends PitmanArm {}

abstract sig LightRotarySwitch {}
one sig LightSwitchOff extends LightRotarySwitch {}
one sig LightSwitchOn extends LightRotarySwitch {} 
one sig LightSwitchAuto extends LightRotarySwitch {} 


fact init {
	Input.pitmanArm in PitmanArmNeutral
     Input.lightRotarySwitch in LightSwitchOff
     Signal in Off
     no ( Car.frontRight + Car.frontLeft +
	     Car.middleRight + Car.middleLeft +
	     Car.backRight + Car.backLeft +
	     Car.top )

}

run {} for 50
