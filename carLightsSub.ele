abstract sig Lights{}

-- the lights may be in one of the following states
var sig On in Lights {} 
var sig Off in Lights {}
var sig Flashing in Lights {
	var state: one FlashingMode
   -- all flashing are flashing in the same mode 
} 

-- not sure if needed
abstract sig FlashingMode {}
one sig QuickFlashing extends FlashingMode {}
one sig NormalFlashing extends FlashingMode {}

abstract sig TurnSignal extends Lights {}
one sig LeftTurnSignal extends TurnSignal {}
one sig RightTurnSignal extends TurnSignal {}

one sig EmergencyBreakLight extends Lights {}
one sig AdaptiveHighBeam extends Lights {}
one sig LowBeamHeadlights extends Lights {}

abstract sig CorneringLights extends Lights {}
one sig LeftCorneringLight extends CorneringLights {}
one sig RightCorneringLight extends CorneringLights {}

one sig Input {
	var pitmanArm: one PitmanArm,
     var lightRotarySwitch: one LightRotarySwitch
}

abstract sig PitmanArm {
 -- 5ยบ/10ยบ could be done with a ternary relation here
 -- but some since ยบ doesn't matter for left and right
 -- that would allow to represent "impossible" states
 -- hence this solution
}
one sig PitmanArmNeutral extends PitmanArm {}
one sig PitmanArmUp5 extends PitmanArm {}
one sig PitmanArmUp10 extends PitmanArm {}
one sig PitmanArmDown5 extends PitmanArm {}
one sig PitmanArmDown10 extends PitmanArm {}
one sig PitmanArmLeft extends PitmanArm {}
one sig PitmanArmRight extends PitmanArm {}

abstract sig LightRotarySwitch {}
one sig LightSwitchOff extends LightRotarySwitch {}
one sig LightSwitchOn extends LightRotarySwitch {} 
one sig LightSwitchAuto extends LightRotarySwitch {} 

-- On/Off/FlashingAdaptiveHighBeam can't be "extended" since they are supposed
-- to be disjoint between themselves but not between "light types"
-- On/Off/Flashing could be inside "Light" (Light { state: State }) but
-- the theme wouldn't be so explicit, hence the current model 
fact oneMode { 
	always (
 		Lights = On + Off + Flashing and
		no On & Off and
		no Off & Flashing and
		no On & Flashing 
	)
}


fact onlyOneSide {
	always (LeftTurnSignal in Flashing implies RightTurnSignal not in Flashing
	         and RightTurnSignal in Flashing implies LeftTurnSignal not in Flashing)
	always (LeftCorneringLight in On implies RightCorneringLight not in On
	         and RightCorneringLight in On implies LeftCorneringLight not in On)
}

pred on[l : Lights] {
	l in Off

	Off' = Off - l
	On' = On + l

	Flashing' = Flashing
}

pred off[l : Lights] {
	l in On

	On' = On - l
	Off' = Off + l

	Flashing' = Flashing
}

pred turn[t : TurnSignal, c : CorneringLights] {
	t in Off
     c in Off


	Off' = Off - (t + c)
	Flashing' = Flashing + t
     On' = On + c
}

pred unturn[t : TurnSignal, c : CorneringLights] {
	t in Flashing
     c in On

	Flashing' = Flashing - t
     On' = On - c
	Off' = Off + (t + c)
}

pred turn_left[] {
 turn[LeftTurnSignal, LeftCorneringLight]
}
pred unturn_left[] {
 unturn[LeftTurnSignal, LeftCorneringLight]
}
pred turn_right[] {
 turn[RightTurnSignal, RightCorneringLight]
}
pred unturn_right[] {
 unturn[RightTurnSignal, RightCorneringLight]
}

pred turn_unturn[] {
 turn_left or unturn_left or
 turn_right or unturn_right
}


pred do_nothing[] {
	On' = On
	Off' = Off
	Flashing' = Flashing
}

fact init {
	Lights in Off
	Input.pitmanArm in PitmanArmNeutral
     Input.lightRotarySwitch in LightSwitchOff
}

fact transitions {
  always (
   turn_unturn or on[EmergencyBreakLight] or off[EmergencyBreakLight] or do_nothing
  )
}

run {} for 50
