abstract sig Lights{}

var sig On in Lights {} 
var sig Off in Lights {}
var sig Flashing in Lights {} 


abstract sig TurnSignal extends Lights {}
one sig LeftTurnSignal extends TurnSignal {}
one sig RightTurnSignal extends TurnSignal {}

one sig EmergencyBreakLight extends Lights {}
one sig AdaptiveHighBeam extends Lights {}
one sig LowBeamHeadlights extends Lights {}

abstract sig CorneringLights extends Lights {}
one sig LeftCorneringLight extends CorneringLights {}
one sig RightCorneringLight extends CorneringLights {}


fact oneMode { 
	always (
 	Lights = On + Off + Flashing and
	no On & Off and
	no Off & Flashing and
	no On & Flashing 
	)
}


fact onlyOne {
	always (LeftTurnSignal in On implies RightTurnSignal not in On
	         and RightTurnSignal in On implies LeftTurnSignal not in On)
	always (LeftCorneringLight in On implies RightCorneringLight not in On
	         and RightCorneringLight in On implies LeftCorneringLight not in On)
}

pred on[l : Lights] {
	l in Off

	Off' = Off - l
	On' = On + l

	Flashing' = Flashing
}

pred off[l : Lights] {
	l in On

	On' = On - l
	Off' = Off + l

	Flashing' = Flashing
}

pred turn[l : Lights] {
	l in Off

	Off' = Off - l
	Flashing' = Flashing + l

	On' = On
}

pred unturn[l : Lights] {
	l in Flashing

	Flashing' = Flashing - l
	Off' = Off + l

	On' = On
}

pred turn_left[] {
 turn[LeftTurnSignal]
}
pred unturn_left[] {
 unturn[LeftTurnSignal]
}
pred turn_right[] {
 turn[RightTurnSignal]
}
pred unturn_right[] {
 unturn[RightTurnSignal]
}

pred turn_unturn[] {
 turn_left or unturn_left or
 turn_right or unturn_right
}


pred do_nothing[] {
	On' = On
	Off' = Off
	Flashing' = Flashing
}

fact init {
	Lights in Off
}

fact transitions {
  always (
   turn_unturn or on[EmergencyBreakLight] or off[EmergencyBreakLight] or do_nothing
  )
}

run{} for 50
